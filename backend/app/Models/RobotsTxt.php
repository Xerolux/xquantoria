<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class RobotsTxt extends Model
{
    protected $table = 'robots_txt';

    protected $fillable = [
        'content',
        'updated_by',
        'last_generated_at',
    ];

    protected $casts = [
        'last_generated_at' => 'datetime',
    ];

    public function updater()
    {
        return $this->belongsTo(User::class, 'updated_by');
    }

    /**
     * Get the robots.txt content as array
     */
    public function getRulesAttribute(): array
    {
        if (empty($this->content)) {
            return [];
        }

        $rules = [];
        $currentUserAgent = null;

        $lines = explode("\n", $this->content);
        foreach ($lines as $line) {
            $line = trim($line);

            // Skip empty lines and comments
            if (empty($line) || str_starts_with($line, '#')) {
                continue;
            }

            // User-agent line
            if (preg_match('/^User-agent:\s*(.+)$/i', $line, $matches)) {
                $currentUserAgent = trim($matches[1]);
                if (!isset($rules[$currentUserAgent])) {
                    $rules[$currentUserAgent] = [];
                }
                continue;
            }

            // Other directives (Disallow, Allow, Crawl-delay, Sitemap, etc.)
            if (preg_match('/^(\w+):\s*(.+)$/', $line, $matches)) {
                $directive = strtolower($matches[1]);
                $value = trim($matches[2]);

                if ($currentUserAgent) {
                    $rules[$currentUserAgent][] = [
                        'directive' => $directive,
                        'value' => $value,
                    ];
                }
            }
        }

        return $rules;
    }

    /**
     * Generate default robots.txt content
     */
    public static function generateDefault(): string
    {
        return implode("\n", [
            '# Robots.txt',
            '# Generated by Blog CMS',
            '# Last updated: ' . now()->toDateTimeString(),
            '',
            'User-agent: *',
            'Allow: /',
            'Disallow: /admin',
            'Disallow: /api',
            'Disallow: /storage',
            '',
            '# Crawl-delay (optional)',
            '# Crawl-delay: 1',
            '',
            '# Sitemap',
            'Sitemap: ' . url('/sitemap.xml'),
            '',
            '# Disallow specific file types',
            'Disallow: /*.pdf$',
            'Disallow: /*.doc$',
            'Disallow: /*.docx$',
            '',
            '# Allow common bots',
            'User-agent: Googlebot',
            'Allow: /',
            '',
            'User-agent: Bingbot',
            'Allow: /',
        ]);
    }

    /**
     * Validate robots.txt content
     */
    public function validateContent(): array
    {
        $errors = [];
        $lines = explode("\n", $this->content);

        foreach ($lines as $lineNumber => $line) {
            $lineNumber++; // 1-based index

            // Skip empty lines and comments
            $trimmedLine = trim($line);
            if (empty($trimmedLine) || str_starts_with($trimmedLine, '#')) {
                continue;
            }

            // Validate directive format
            if (!preg_match('/^[\w-]+:\s*.+$/', $trimmedLine)) {
                $errors[] = "Line {$lineNumber}: Invalid format. Expected 'Directive: value'";
                continue;
            }

            // Extract directive and value
            preg_match('/^([\w-]+):\s*(.+)$/', $trimmedLine, $matches);
            $directive = strtolower($matches[1]);
            $value = trim($matches[2]);

            // Validate known directives
            $validDirectives = [
                'user-agent',
                'disallow',
                'allow',
                'crawl-delay',
                'request-rate',
                'sitemap',
                'clean-param',
            ];

            if (!in_array($directive, $validDirectives)) {
                $errors[] = "Line {$lineNumber}: Unknown directive '{$directive}'";
            }

            // Validate User-agent
            if ($directive === 'user-agent' && empty($value)) {
                $errors[] = "Line {$lineNumber}: User-agent cannot be empty";
            }

            // Validate Disallow/Allow paths
            if (in_array($directive, ['disallow', 'allow'])) {
                if (!str_starts_with($value, '/') && $value !== '*') {
                    $errors[] = "Line {$lineNumber}: {$directive} path should start with '/' or be '*'";
                }
            }

            // Validate Crawl-delay
            if ($directive === 'crawl-delay') {
                if (!is_numeric($value) || $value < 0) {
                    $errors[] = "Line {$lineNumber}: Crawl-delay must be a positive number";
                }
            }

            // Validate Sitemap
            if ($directive === 'sitemap') {
                if (!filter_var($value, FILTER_VALIDATE_URL)) {
                    $errors[] = "Line {$lineNumber}: Sitemap must be a valid URL";
                }
            }
        }

        return $errors;
    }
}
